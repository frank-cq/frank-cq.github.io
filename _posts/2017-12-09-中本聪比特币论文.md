---
layout: post
title: 中本聪比特币论文
categories: []
tags: [bitcoin,blockchain]
comments: true
---

[中本聪（Satoshi Nakamoto）](https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA)，又译中本哲史，于2008年发布了比特币的创世论文《Bitcoin: A Peer-to-Peer Electronic Cash System》。在论文中描述了一种基于加密技术的新的电子货币系统。

---
# Bitcoin: A Peer-to-Peer Electronic Cash System

> Abstract: 纯点对点版本的电子现金系统将允许直接从一方在线付款到另一方，而不经过一个金融机构。数字签名提供了解决方案的一部分，但如果仍然需要一个可信第三方来防止双重支付，就将丧失大部分的收益。我们基于点对点网络提出了双重支付问题的解决方案。点对点网络添加时间戳的方式为将交易的哈希值添加到一条不断增长的链中——该链采用基于哈希的工作量证明方式进行增长，必须重新进行工作量证明才能修改记录。最长的链不仅作为观察到的事件序列的证明，也作为自身来自最大算力池的证明。只要点对点网络的大部分算力被合作节点掌握，他们就能够超过攻击者，生成最长的链。该网络本身需要最小的结构，其中的消息以尽力而为的方式广播，节点可以随意离开或重新加入网络，并接受最长的工作量证明链，以此确证他们不在网络期间发生的事。

## 1. Introduction
互联网上的商业几乎完全依赖于金融机构作为可信第三方来处理电子支付。虽然在大多数交易下系统都运行良好，但这种基于信任的模式仍有其固有弱点。完全不可逆的交易是不可能的，因为金融机构不能避免调解纠纷。调解的成本增加了交易成本，限制了最小的实际交易规模，切断了小额临时交易的可能性，并且因为为不可逆服务提供不可逆支付能力的丧失而产生更广泛的成本。由于交易可被逆转，对信任的要求增加。商家必须警惕他们的顾客，尽可能多地获取他们本不需要的信息。一定比例的欺诈被认为是不可避免的。这些成本和支付不确定性可以通过亲自使用实物货币来避免，但没有任何机制可以使通过没有信任方的通信渠道进行支付成为可能。

所需要的是基于密码证明而不是信任的电子支付系统，允许任何两个自愿的双方直接交易，而不需要一个可信第三方。在计算上不可逆转的交易将保护卖家免受欺诈，常规托管机制也可以很容易地实施，以保护买家。本文提出了一种双重支付问题的解决方案，即采用点对点分布式时间戳服务器来生成交易的时间顺序的计算证明。只要诚实节点所控制的总算力比攻击节点控制的更多，该系统就是安全的。
## 2. Transactions
我们将电子币定义为数字签名链。币的转移是通过所有者对前一个交易和下一个所有者的公匙进行签名，并将这两个签名放到币的末端来实现。收款人可以通过验证签名来验证链所有权。

![](assets/transactions.png)

当然，问题是收款人无法验证其中一个所有者没有进行双重支付。一个常见的解决办法是引入一个可信中央权威机构（造币厂），检查交易是否被双重支付。每次交易后，必须将币退还给造币厂以发行新的币，只有从造币厂发行的币可以确信没有双花。这个解决方案的问题是，整个货币体系的命运取决于运营造币厂的公司，每一笔交易都要经过它们，就像银行一样。

我们需要一种方法让收款人知道前所有者没有将币用于早些的交易。就这个目的而言，最早的交易是最关键的，所以我们不关心稍后是否进行了双花。确认交易是否存在的唯一方法是了解所有交易。在造币厂模型中，造币厂了解所有的交易，并决定哪一个交易是第一个。为了在没有信任方的情况下达到这个目的，交易必须被公开宣布<sup>[1]</sup>，我们需要一个系统让参与者基于他们接收到的事实就序列的单一历史达成共识。收款人需要证据，表明在每次交易时，大多数节点都同意这是第一次收到。

>关键信息：币所有者对该笔交易签名、对下一个所有者的公匙签名
## 3. Timestamp Server
我们建议的解决方案是从一个时间戳服务器开始。时间戳服务器通过对多个项目组成的区块进行哈希来得到时间戳，并广泛发布该哈希值，如在报纸或Usenet帖子<sup>[2-5]</sup>中。时间戳用于证明数据在得到哈希值的那个时间点存在。每个时间戳的哈希值中都包含之前的时间戳，形成一个链，每个新加的时间戳都对它之前的时间戳进行了增强。

>关键信息：当前的时间戳中包含前一个时间戳的摘要

![](assets/timestamp_server.png)
## 4. Proof-of-Work
要在点对点基础上实现分布式时间戳服务器，我们需要使用类似于Adam Back的Hashcash<sup>[6]</sup>的工作量证明机制，而不是报纸或Usenet帖子。工作量证明涉及在哈希后检索一个值，例如SHA-256，得到的哈希值以一定数量的零比特位开始。所需的平均工作量与要求的零比特位的数量呈指数关系，并且答案通过一次哈希就可以验证。

对于我们的时间戳网络，工作量证明机制这样实现：在区块中递增一个nonce值，针对每次的nonce，计算整个区块的哈希值，直到找到一个哈希值，该值满足所要求的零比特位数量。一旦CPU已经花费了努力使其满足工作量证明，不重做该工作的情况下无法改变块。后来的块被放入链后，改变该块所需的工作量将包括重做之后所有块的工作。

![](assets/PoW.png)

工作量证明机制也解决了在多数决策制定中确定哪个为代表的问题。如果大多数的定义是基于一个IP地址一票的话，能够分配许多IP的人将可以破坏该系统。工作证明本质上是一个CPU一票。大多数的决定由最长的链代表，因为其包含了最多的工作证明工作。如果大部分的CPU能力都是由诚实的节点来控制，诚实的链条就会增长最快，超过任何竞争链。要修改过去的块，攻击者将不得不重做之后所有区块的工程证明，然后赶上并超越诚实节点的工作。稍后我们会展示一个较慢攻击者追赶的概率随着随后的块被添加，指数性地减小。

为了补偿硬件速度的增加和随着时间的推移对运行节点的兴趣变动，工作证明的难度取决于一个变化的平均数——每小时生成区块数量。如果产生得太快，难度就会增加。

>关键信息：通过递增nonce，获得符合要求的hash值；根据算力变化调整难度
## 5. Network
运行网络的步骤如下：

1. 新交易广播给所有节点。
2. 每个节点收集新的交易到一个块。
3. 每个节点的工作是找到一个困难的块工作证明。
4. 当节点发现工作证明时，它将该块广播给所有节点。
5. 只有在块中所有交易都有效且尚未支过的情况下，节点才接受该块。
6. 节点通过在链上创建下一个块来表示他们接受了该块，并使用接受块的哈希作为新创建块的前导哈希。

节点总是认为最长的链是正确的，并将继续扩展它。如果两个节点同时广播了下一个块的不同版本，则会有一些节点先接收到这一个或那一个。在那种情况下，他们在收到的第一个块上面工作，但保存其他分支，以防其他分支变得更长。当下一个工作证明被找到，一个分支变得更长时，均势将被打破; 在另一个分支上工作的节点会切换到这个较长的分支。

新交易的广播不一定要到达所有的节点。只要他们到达很多节点，不久就会进入一个块。块广播也容忍消息丢失。如果一个节点没有收到一个块，它会在收到下一个块时意识到错过了一个块，并请求它。

>关键信息：保存其他分支，在最长分支上工作
## 6. Incentive
按照惯例，块中的第一笔交易是一个特殊的交易，其中生成的币归属于块的产生者。这激励了节点支持这个网络，并提供了一种发行币、投入流通的方式，因为没有中央机构来发行它们。稳定增加一定数量的新币类比于黄金挖矿工消耗资源挖到黄金然后投入流通领域。在我们的机制中，这是CPU时间和电力消耗。

交易费也可以作为激励。如果交易的输出值小于其投入价值，差额就是交易费用——作为包含该交易的区块的追加激励。一旦预定数量的币已经进入流通，激励可以完全转移到交易费用，完全不会有通货膨胀。

激励可能有助于鼓励节点保持诚实。如果一个贪婪的攻击者能够比所有诚实的节点组装更多的CPU算力，他将不得不面临选择：使用算力窃回他的付款来实现欺诈，或者用它来生成新的币。他应该发现按照规则出牌更有利可图——这种规则保障他获得的新币比其他人联合起来所获得的都要多，而不是破坏规则，损害自己的财富的有效性。

>关键信息：块生成激励；交易费激励
## 7. Reclaiming Disk Space
一旦币的最新交易被足够多的区块淹没之后，之前的花费交易记录可以被丢弃以节省磁盘空间。为了在不破坏块的哈希的情况下实现这一点，交易在Merkle树<sup>[7][2][5]</sup>中被哈希，并且只有Merkle树根包含在块哈希中。老区块可以通过剪枝来压缩大小。Merkle树内部哈希不需要保存。

![](assets/Merkle.png)

没有交易记录的区块头大概是80个字节。假设每10分钟产生一个区块，每年就是 80字节* 6 * 24 * 365 = 4.2MB。考虑在2008年以前，销售的计算机系统一般都有2GB内存，且摩尔定律预测目前的增长速度每年增加1.2GB，即使区块头必须装入内存中，内存大小也不应该成为问题。
## 8. Simplified Payment Verification
可以在不运行完整网络节点的情况下验证付款。用户只需要保留最长的工作证明链的区块头副本，他可以通过查询可确认为最长的链上的网络节点获得这个区块头，最长链上包括了用户交易所在的Merkle分支所连接到的时间戳。他不能自己确认这笔交易，但通过将这笔交易链接到链中的一个地方，他可以看到一个网络节点已经接受它，并区块将在该网络节点进一步确认网络已经接受该交易之后被添加。

![](assets/SPV.png)

因此，只要诚实的节点控制网络，验证就是可靠的，但如果网络被攻击者控制的话，验证就会更脆弱。因为网络节点可以自己验证交易，只要攻击者可以持续控制网络，简化方法就会被黑客捏造的交易愚弄。一个防止这种情况的策略是在网络节点检测到无效区块时接受警报，并提示用户的软件下载完整的块与被提醒的交易，以确认不一致性。接受付款频繁的企业可能仍然希望运行自己的节点以获得更加独立的安全性和更快的验证。
## 9. Combining and Splitting Value
虽然单独处理币是可能的，但每一分币要单独交易还是不容易的。为了让价值能被分割和合并，交易包含多个输入和输出。通常会有一个来自较大的前导交易的单一输入或多个来自较小前导交易汇总的输入，最多两个输出：一个用于付款，另一个用于将找零（如果有）返还给发起人。

![](assets/CSV.png)

应该指出，交易的输出依赖于前几个交易，前几个交易又依赖前面更多的交易，并不是问题。没有必要提取一个完整的交易记录的独立副本。
## 10. Privacy
传统的银行业务模式通过限制当事人和可信第三方对信息的获取来实现一定程度的隐私保护。这里，从公布所有交易的必要性上就排除了这种方法，但隐私仍然可以被保护，通过打破另一个方向的信息流：保持公钥匿名。公众可以看到有人发送了一个金额给其他人，但没有可以将交易连接到任何人的信息。 这类似于证券交易所的信息披露机制，交易时间、个人交易规模、the 'tape'都是公开的，但没有告知谁是当事人。

![](assets/privacy.png)

作为额外的防范措施，每笔交易都应该使用一对新的密钥，以保障它们不会指向共同的所有者。在多点输入的交易中，一些联系仍然不可避免，必然显示他们的输入为同一个所有者。风险是如果一个密钥的所有者被揭示，那么可以揭示其他交易也属于该所有者。
## 11. Calculations
考虑以下场景，攻击者试图以比诚实链更快的速度生成另一条链。即使这样做完成，也不会使系统对任意改变开放，例如无中生有创造价值或者得到从不属于攻击者的金钱。节点不会接受无效的交易作为付款，诚实的节点永远不会接受一个包含它们的块。攻击者只能尝试改变他自己的一个交易来收回他最近花了的钱。

诚实链和攻击者链之间的竞争可以被定性为二项式随机游走。成功事件是诚实的链条延伸了一个区块，通过+1扩大领先，而失败事件是攻击者的链延伸一个区块，通过-1减少了差距。

攻击者从给定的落后中追赶的概率类似于赌徒的概率废墟问题。假设一个无限信用的赌徒从赤字开始进行无限次的尝试，以达到盈亏平衡。我们可以计算他达到盈亏平衡的概率，或攻击者追赶上诚实的链条的概率，如下<sup>[8]</sup>：

p =诚实节点找到下一个块的概率

q =攻击者找到下一个块的概率

q<sub>z</sub> =攻击者将从后面z个块追上的概率

![](assets/catchup.png)

假设 p > q，成功概率随着攻击者需要追赶的块的数量的增加而呈指数下降。因为胜算不在攻击者这边，如果他没有一个幸运大逃杀的话，那么他的机会只会变得越来越小。

我们现在考虑一个新交易的接收者需要等待多长时间，才能充分确定发起人不能更改交易。我们假设发起人是攻击者，他想让接受者相信他已经支付给他一段时间，一段时间过去后他却把币交还给自己。当发生这种情况时，接收人将被提醒，但是发起人希望这个提醒到来时已经晚了。

接收方生成一个新的密钥对，并在签约前不久将公钥发送给发送方签约。这可以防止发送方提前准备好一条区块链，并他有足够的幸运可以生成一条更长的链，在那一刻执行交易。一旦交易被发送，不诚实的发送方开始秘密地工作在包含他的交易的替代版本的另一条链上。

接收方等待，直到交易被添加到一个块，并且Z个块连接到它后面。他不知道攻击者取得进展的确切数量，但是假设诚实的数据块占用了每块的平均预期时间，攻击者的潜在进展将是一个泊松分布，其期望为：

![](assets/PoD.png)

为了得到攻击者现在还能追上的概率，我们把他可能已经取得的进展数量的泊松密度乘以他从这一点上可能赶上的概率：

![](assets/PoDes.png)

重新排列，以避免总结泊松分布的无限尾巴...

![](assets/PoDRs.png)

转化为C代码...

![](assets/PoDC.png)

运行一些结果，我们可以看到概率随着z呈指数下降。
```
q=0.1
z=0     P=1.0000000
z=1     P=0.2045873
z=2     P=0.0509779
z=3     P=0.0131722
z=4     P=0.0034552
z=5     P=0.0009137
z=6     P=0.0002428
z=7     P=0.0000647
z=8     P=0.0000173
z=9     P=0.0000046
z=10    P=0.0000012

q=0.3
z=0     P=1.0000000
z=5     P=0.1773523
z=10    P=0.0416605
z=15    P=0.0101008
z=20    P=0.0024804
z=25    P=0.0006132
z=30    P=0.0001522
z=35    P=0.0000379
z=40    P=0.0000095
z=45    P=0.0000024
z=50    P=0.0000006
```

解决P小于0.1％...
```
P < 0.001
q=0.10  z=5
q=0.15  z=8
q=0.20  z=11
q=0.25  z=15
q=0.30  z=24
q=0.35  z=41
q=0.40  z=89
q=0.45  z=340
```

## 12. Conclusion
我们提出了一个不依靠信任的电子交易系统。我们从数字签名构成的通用币框架开始，数字签名提供了对所有权强有力的控制，但由于没有办法防止双重支付，仍然是不完整的。为了解决这个问题，我们提出了一个使用工作证明记录交易的公共历史的对等网络，在诚实节点控制多数算力的情况下，攻击者要改变交易很快变得不切实际。该网络非结构化的简单，使得其健壮。所有节点只需要一点点的沟通就可同时工作。他们不需要被识别，因为信息没有路由到任何特定的地方，只需要以尽力而为的方式交付。节点可以随意离开或重新加入网络，并接受最长的工作量证明链，以此确证他们不在网络期间发生的事。他们用算力进行投票，扩展接受的链，拒绝工作在包含无效区块的链上。任何需要的规则和激励都可以通过这个共识机制来实施。

## References
[1] W. Dai, "b-money," http://www.weidai.com/bmoney.txt, 1998.

[2] H. Massias, X.S. Avila, and J.-J. Quisquater, "Design of a secure timestamping service with minimal
trust requirements," In 20th Symposium on Information Theory in the Benelux, May 1999.

[3] S. Haber, W.S. Stornetta, "How to time-stamp a digital document," In Journal of Cryptology, vol 3, no
2, pages 99-111, 1991.

[4] D. Bayer, S. Haber, W.S. Stornetta, "Improving the efficiency and reliability of digital time-stamping,"
In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.

[5] S. Haber, W.S. Stornetta, "Secure names for bit-strings," In Proceedings of the 4th ACM Conference
on Computer and Communications Security, pages 28-35, April 1997.
[6] A. Back, "Hashcash - a denial of service counter-measure,"
http://www.hashcash.org/papers/hashcash.pdf, 2002.

[7] R.C. Merkle, "Protocols for public key cryptosystems," In Proc. 1980 Symposium on Security and
Privacy, IEEE Computer Society, pages 122-133, April 1980.

[8] W. Feller, "An introduction to probability theory and its applications," 1957.
9








