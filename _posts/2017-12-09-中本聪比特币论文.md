---
layout: post
title: 中本聪比特币论文
categories: []
tags: [Bitcoin,Blockchain]
comments: true
---

[中本聪（Satoshi Nakamoto）](https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA)，又译中本哲史，于2008年发布了比特币的创世论文《Bitcoin: A Peer-to-Peer Electronic Cash System》。在论文中描述了一种基于加密技术的电子货币系统。

---
# Bitcoin: A Peer-to-Peer Electronic Cash System

> Abstract: 纯点对点版本的电子现金系统将允许直接从一方在线付款到另一方，而不经过一个金融机构。数字签名提供了部分的解决方案，但如果仍然需要一个可信第三方来防止双花，就将丧失意义。我们基于点对点网络提出了双花问题的解决方案。点对点网络添加时间戳的方式为将交易的哈希值添加到一条不断增长的链中——该链采用基于哈希的工作量证明方式进行增长，修改记录必须重新进行工作量证明。最长的链不仅作为观察到的事件序列的证明，也作为自身来自最大算力池的证明。只要点对点网络的大部分算力被合作节点掌握，他们就能够超过攻击者，生成最长的链。该网络本身需要最小的结构，其中的消息以尽力而为的方式广播，节点可以随意离开或重新加入网络，并接受最长的工作量证明链，以此确证他们不在网络期间发生的事。

## 1. Introduction
互联网上的商业几乎完全依赖于金融机构作为可信第三方来处理电子支付。虽然在大多数交易下系统都运行良好，但这种基于信任的模式仍有其固有弱点。完全不可逆的交易是不可能的，因为金融机构不能避免调解纠纷。调解的成本增加了交易成本，限制了最小的实际交易规模，切断了小额临时交易的可能性，并且因为为不可逆服务提供不可逆支付能力的丧失而产生更广泛的成本。由于交易可被逆转，对信任的要求增加。商家必须警惕他们的顾客，尽可能多地获取他们本不需要的信息。一定比例的欺诈被认为是不可避免的。这些成本和支付不确定性可以通过亲自使用实物货币来避免，但没有任何机制可以使通过没有信任方的通信渠道进行支付成为可能。

所需要的是基于密码证明而不是信任的电子支付系统，允许任何两个自愿的双方直接交易，而不需要一个可信第三方。在计算上不可逆转的交易将保护卖家免受欺诈，常规托管机制也可以很容易地实施，以保护买家。本文提出了一种双花问题的解决方案，即采用点对点分布式时间戳服务器来生成交易的时间顺序的计算证明。只要诚实节点所控制的总算力比攻击节点控制的更多，该系统就是安全的。
## 2. Transactions
我们将电子币定义为数字签名链。币的转移是通过所有者对前一笔交易和下一个所有者的公匙进行签名，并将这两个签名放到币的末端来实现。收款人可以通过验证签名来验证链所有权。

![](assets/transactions.png)

当然，问题是收款人无法验证其中一个所有者没有进行双花。一个常见的解决办法是引入一个可信中央权威机构（造币厂），检查交易是否被双花。每次交易后，必须将币退还给造币厂以发行新的币，只有从造币厂发行的币可以确信没有双花。这个解决方案的问题是，整个货币体系的命运取决于运营造币厂的公司，每一笔交易都要经过它们，就像银行一样。

我们需要一种方法让收款人知道前所有者没有将币用于早些的交易。就这个目的而言，最早的交易是最关键的，所以我们不关心稍后是否进行了双花。确认交易是否存在的唯一方法是了解所有交易。在造币厂模型中，造币厂了解所有的交易，并决定哪一笔交易是第一个。为了在没有信任方的情况下达到这个目的，交易必须被公开宣布<sup>[1]</sup>，我们需要一个系统让参与者基于他们接收到的事实就序列的单一历史达成共识。收款人需要证据，表明在每次交易时，大多数节点都同意这是第一次收到。

>关键信息：币所有者对该笔交易签名、对下一个所有者的公匙签名

## 3. Timestamp Server
我们建议的解决方案是从一个时间戳服务器开始。时间戳服务器通过对多个项目组成的区块进行哈希来得到时间戳，并广泛发布该哈希值，如在报纸或Usenet帖子<sup>[2-5]</sup>中。时间戳用于证明数据在得到哈希值的那个时间点存在。每个时间戳的哈希值中都包含之前的时间戳，形成一个链，每个新加的时间戳都对它之前的时间戳进行了增强。

>关键信息：当前的时间戳中包含前一个时间戳的摘要

![](assets/timestamp_server.png)
## 4. Proof-of-Work
要在点对点基础上实现分布式时间戳服务器，我们需要使用类似于Adam Back的Hashcash<sup>[6]</sup>的工作量证明机制，而不是报纸或Usenet帖子。工作量证明涉及在哈希后检索一个值，例如SHA-256，得到的哈希值以一定数量的零比特位开始。所需的平均工作量与要求的零比特位的数量呈指数关系，并且答案通过一次哈希就可以验证。

对于我们的时间戳网络，工作量证明机制这样实现：在区块中递增一个nonce值，针对每次的nonce，计算整个区块的哈希值，直到找到一个哈希值，该值满足所要求的零比特位数量。一旦CPU已经花费了努力使其满足工作量证明，不重做该工作的情况下无法改变块。后来的块被放入链后，改变该块所需的工作量将包括重做之后所有块的工作。

![](assets/PoW.png)

工作量证明机制也解决了在多数决策制定中确定哪个为代表的问题。如果大多数的定义是基于一个IP地址一票的话，能够分配许多IP的人将可以破坏该系统。工作量证明本质上是一个CPU一票。大多数的决定由最长的链代表，因为其包含了最多的工作量证明工作。如果大部分的CPU能力都是由诚实的节点来控制，诚实的链条就会增长最快，超过任何竞争链。要修改过去的块，攻击者将不得不重做之后所有区块的工程证明，然后赶上并超越诚实节点的工作。稍后我们会展示一个较慢攻击者追赶的概率随着随后的块被添加，指数性地减小。

为了补偿硬件速度的增加和随着时间的推移对运行节点的兴趣变动，工作量证明的难度取决于一个变化的平均数——每小时生成区块数量。如果区块产生得太快，难度就会增加。

>关键信息：通过递增nonce，获得符合要求的hash值；根据全网算力变化调整难度

## 5. Network
运行网络的步骤如下：

1. 新交易广播给所有节点。
2. 每个节点收集新的交易到一个块。
3. 每个节点的工作是找到一个困难的块工作量证明。
4. 当节点发现工作量证明时，它将该块广播给所有节点。
5. 只有在块中所有交易都有效且尚未支过的情况下，节点才接受该块。
6. 节点通过在链上创建下一个块来表示他们接受了该块，并使用接受块的哈希作为新创建块的前导哈希。

节点总是认为最长的链是正确的，并将继续扩展它。如果两个节点同时广播了下一个块的不同版本，则会有一些节点先接收到这一个或那一个。在那种情况下，他们在收到的第一个块上面工作，但保存其他分支，以防其他分支变得更长。当下一个工作量证明被找到，一个分支变得更长时，均势将被打破; 在另一个分支上工作的节点会切换到这个较长的分支。

新交易的广播不一定要到达所有的节点。只要他们到达很多节点，不久就会进入一个块。块广播也容忍消息丢失。如果一个节点没有收到一个块，它会在收到下一个块时意识到错过了一个块，并请求它。

>关键信息：保存其他分支，在最长分支上工作

## 6. Incentive
按照惯例，块中的第一笔交易是一个特殊的交易，其中生成的币归属于块的产生者。这激励了节点支持这个网络，并提供了一种发行币、投入流通的方式，因为没有中央机构来发行它们。稳定增加一定数量的新币类比于黄金挖矿工消耗资源挖到黄金然后投入流通领域。在我们的机制中，这是CPU时间和电力消耗。

交易费也可以作为激励。如果交易的输出值小于其投入价值，差额就是交易费用——作为包含该交易的区块的追加激励。一旦预定数量的币已经进入流通，激励可以完全转移到交易费用，完全不会有通货膨胀。

激励可能有助于鼓励节点保持诚实。如果一个贪婪的攻击者能够比所有诚实的节点组装更多的CPU算力，他将不得不面临选择：使用算力窃回他的付款来实现欺诈，或者用它来生成新的币。他应该发现按照规则出牌更有利可图——这种规则保障他获得的新币比其他人联合起来所获得的都要多，而不是破坏规则，损害自己的财富的有效性。

>关键信息：块生成激励；交易费激励

## 7. Reclaiming Disk Space
当新交易被放入链中，且在该链后扩展了足够多的区块之后，可以确认该交易不会被撤销，则可以丢球该交易之前的交易记录，以节省磁盘空间。为了在不破坏块的哈希的情况下实现这一点，交易在Merkle树<sup>[7][2][5]</sup>中被哈希，并且只有Merkle树根包含在块哈希中。老区块可以通过这样的修剪来压缩大小。除Merkle树根外，不需要保存其他内部哈希。

![](assets/Merkle.png)

没有交易记录的区块头大概是80个字节。假设每10分钟产生一个区块，每年就是 80字节* 6 * 24 * 365 = 4.2MB。在2008年以前，计算机系统一般都有2GB内存，且摩尔定律预测内存以每年1.2GB的速度增长，所以即使必须将所有区块头都装入内存中，也不是问题。

## 8. Simplified Payment Verification
可以在不运行完整网络节点的情况下验证付款。用户只需要保留最长链的区块头副本，他可以不断发起查询，直到确认拥有最长的链，这条链上的某个区块可以连接到用户交易所在的Merkle分支。用户原本不能自行确认这笔交易的有效性，但通过将这笔交易链接到链中，他可以看到一个节点已经接受它，并且在它之后又链接了新的区块，这表明交易已被全网确认。

![](assets/SPV.png)

因此，只要诚实的节点控制网络，验证就是可靠的，但如果网络被攻击者控制的话，验证就比较脆弱。因为网络节点可以自己验证交易，只要攻击者可以持续控制网络，简化方法就会被黑客捏造的交易愚弄。一个防止这种情况的策略是在网络节点检测到无效区块时发出警报，提示用户下载无效块或交易的完整信息，以确认不一致性。收款业务频繁的企业可能仍然希望运行自己的节点以获得更加独立的安全性和更快的验证。

## 9. Combining and Splitting Value
虽然单独处理币是可能的，但每一分币要单独交易还是不容易的。为了让价值能被分割和合并，交易包含多个输入和输出。通常会有一个来自较大的前导交易的单一输入或多个来自较小前导交易的汇总输入，输出最多两个：一个用于付款，另一个用于将找零（如果有）返还给发起人。

![](assets/CSV.png)

需要指出，每笔交易依赖于之前多笔交易，这多笔交易又依赖前面更多的交易，这并不是问题。在这种机制中，没有必要展开检验之前的所有交易历史。

## 10. Privacy
传统的银行业务模式通过限制当事人和可信第三方对信息的获取来实现一定程度的隐私保护。在本机制下，因为要公布所有交易，所以这种方法就不行了，但隐私仍然可以被保护，在另一个方向上阻断信息流，即保持公钥匿名。公众可以看到有人发送了一个金额给其他人，但没有可以将交易连接到任何人的信息。这类似于证券交易所的信息披露机制，交易时间、个人交易规模都记录在案且公开，但没有告知谁是当事人。

![](assets/privacy.png)

作为额外的防范措施，每笔交易都应该使用一对新的密钥，以保障它们不会指向共同的所有者。在多点输入的交易中，一些联系仍然不可避免，必然显示他们的输入为同一个所有者。风险是如果一个密钥的所有者被揭示，那么可以揭示出其他交易也属于该所有者。

## 11. Calculations
考虑以下场景，攻击者试图以比诚实链更快的速度生成另一条链。即使这样做完成，也不会使系统对任意改变开放，例如无中生有创造价值或者得到从不属于攻击者的金钱。节点不会接受无效的交易作为付款，诚实的节点永远不会接受一个包含无效交易的块。攻击者只能尝试改变他自己的一笔交易来收回他最近花了的钱。

诚实链和攻击者链之间的竞争可以被定性为二叉树随机游走。成功事件是诚实的链条延伸了一个区块，领先+1，而失败事件是攻击者的链延伸一个区块，差距-1。

攻击者从给定的落后中赶上的概率类似于赌徒破产问题。假设一个无限信用的赌徒从赤字开始进行潜在无限次的尝试，以填补亏损。我们可以计算他填补上亏损的概率，即攻击者追赶上诚实的链条的概率，如下<sup>[8]</sup>：

p = 诚实节点找到下一个块的概率

q = 攻击者找到下一个块的概率

q<sub>z</sub> = 攻击者将从后面z个块追上的概率

![](assets/catchup.png)

假设 p > q，成功概率随着攻击者需要追赶的块的数量的增加而呈指数下降。因为胜算不在攻击者这边，如果他没有足够的幸运快速成功的话，他的机会只会变得越来越小。

我们现在考虑一个新交易的接收者需要等待多长时间，才能充分确定发起人不能更改交易。我们假设发起人是攻击者，他想让接受者在一段时间内相信他已经付款，然后却把币交还给自己。届时，接收人将收到提醒，但为时已晚。

接收方生成一个新的密钥对，并在签约前不久才将公钥发送给发送方签约。这可以防止付款人预先准备好一个区块链然后持续地对此区块进行运算，直到他的区块链恰好超过诚实链条，方才立即执行支付。此时，只要交易一发出，攻击者就开始秘密地准备一条包含了该交易替代版本的平行链条。

接收方等到交易被添加到一个块，并且Z个块连接到它后面。他不知道攻击者取得进展的确切数量，但是假设诚实的区块生成一个新块的时间为平均预期时间，攻击者的潜在进展就是一个泊松分布，其期望为：

![](assets/PoD.png)

为了得到攻击者现在还能追上的概率，我们把他可能已经取得的进展数量的泊松密度乘以他从这一点上可能赶上的概率：

![](assets/PoDes.png)

重新排列，以避免对无限数列求和。

![](assets/PoDRs.png)

转化为C代码...

```c
#include <math.h>
double AttackerSuccessProbability(double q, int z) {
    double p = 1.0 - q;
    double lambda = z * (q / p);
    double sum = 1.0;
    int i, k;
    for (k=0;k<=z;k++) {
        double poisson = exp(-lambda);
        for (i=1;i<=k;i++)
            poisson *= lambda / i;
        sum -= poisson * (1 - pow(q/p,z-k));
    }
    return sum;
}
```

运行，得到一些结果，我们可以看到概率随着z呈指数下降。
```
q=0.1
z=0     P=1.0000000
z=1     P=0.2045873
z=2     P=0.0509779
z=3     P=0.0131722
z=4     P=0.0034552
z=5     P=0.0009137
z=6     P=0.0002428
z=7     P=0.0000647
z=8     P=0.0000173
z=9     P=0.0000046
z=10    P=0.0000012

q=0.3
z=0     P=1.0000000
z=5     P=0.1773523
z=10    P=0.0416605
z=15    P=0.0101008
z=20    P=0.0024804
z=25    P=0.0006132
z=30    P=0.0001522
z=35    P=0.0000379
z=40    P=0.0000095
z=45    P=0.0000024
z=50    P=0.0000006
```

为使P小于0.1％...
```
P < 0.001
q=0.10  z=5
q=0.15  z=8
q=0.20  z=11
q=0.25  z=15
q=0.30  z=24
q=0.35  z=41
q=0.40  z=89
q=0.45  z=340
```

## 12. Conclusion
我们提出了一个不依靠信任的电子交易系统。我们从数字签名构成的通用币框架开始，数字签名提供了对所有权强有力的控制，但由于没有办法防止双花，仍然是不完整的。为了解决这个问题，我们提出了一个使用工作量证明记录交易的公共历史的对等网络，在诚实节点控制多数算力的情况下，攻击者要改变交易会迅速变得不切实际。该网络的强健之处在于它非结构化的简洁性。所有节点只需要少量沟通就可同时工作。他们不需要被识别，因为信息没有路由到任何特定的地方，只需要以尽力而为的方式交付。节点可以随意离开或重新加入网络，并接受最长的工作量证明链，以此确证他们不在网络期间发生的事。他们用算力进行投票，扩展接受的链，拒绝工作在包含无效区块的链上。任何需要的规则和激励都可以通过这个共识机制来实施。


## References
[1] W. Dai, "b-money," http://www.weidai.com/bmoney.txt, 1998.

[2] H. Massias, X.S. Avila, and J.-J. Quisquater, "Design of a secure timestamping service with minimal
trust requirements," In 20th Symposium on Information Theory in the Benelux, May 1999.

[3] S. Haber, W.S. Stornetta, "How to time-stamp a digital document," In Journal of Cryptology, vol 3, no
2, pages 99-111, 1991.

[4] D. Bayer, S. Haber, W.S. Stornetta, "Improving the efficiency and reliability of digital time-stamping,"
In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.

[5] S. Haber, W.S. Stornetta, "Secure names for bit-strings," In Proceedings of the 4th ACM Conference
on Computer and Communications Security, pages 28-35, April 1997.
[6] A. Back, "Hashcash - a denial of service counter-measure,"
http://www.hashcash.org/papers/hashcash.pdf, 2002.

[7] R.C. Merkle, "Protocols for public key cryptosystems," In Proc. 1980 Symposium on Security and
Privacy, IEEE Computer Society, pages 122-133, April 1980.

[8] W. Feller, "An introduction to probability theory and its applications," 1957.
9








